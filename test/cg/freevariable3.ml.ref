(*
 * NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

 * The script is designed to make adding checks to
 * a test case fast, it is *not* designed to be authoritative
 * about what constitutes a good test! The CHECK should be
 * minimized and named to reflect the test intent.


 * CHECK-LABEL:   func.func private @"+"(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i64> attributes {ocaml.unresolved}

 * CHECK-LABEL:   func.func private @funexpr$1(
 * CHECK-SAME:                                 %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !ocaml.box<i64>) -> !ocaml.box<i64> attributes {ocaml.env = "funexpr$1env$2"} {
 * CHECK:           %[[VAL_1:.*]] = ocaml.closure.env.get_current : !ocaml.env
 * CHECK:           %[[VAL_2:.*]] = ocaml.closure.env.get %[[VAL_1]]["i"] -> !ocaml.box<i64>
 * CHECK:           %[[VAL_3:.*]] = ocaml.closure.new @"+" : !ocaml.closure<(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i64>>
 * CHECK:           %[[VAL_4:.*]] = ocaml.call %[[VAL_3]](%[[VAL_0]], %[[VAL_2]]) : (!ocaml.closure<(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i64>>) : !ocaml.box<i64>, !ocaml.box<i64> -> !ocaml.box<i64>
 * CHECK:           return %[[VAL_4]] : !ocaml.box<i64>
 * CHECK:         }

 * CHECK-LABEL:   func.func private @make_adders(
 * CHECK-SAME:                                   %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !ocaml.unit) -> !ocaml.list<!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>>> attributes {ocaml.env = "make_addersenv$0"} {
 * CHECK:           %[[VAL_1:.*]] = ocaml.block : !ocaml.list<!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>>> {
 * CHECK:             %[[VAL_2:.*]] = ocaml.block : !ocaml.ref<!ocaml.list<!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>>>> {
 * CHECK:               %[[VAL_3:.*]] = ocaml.list.new : !ocaml.list<!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>>>
 * CHECK:               %[[VAL_4:.*]] = ocaml.ref %[[VAL_3]] : !ocaml.list<!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>>> -> !ocaml.ref<!ocaml.list<!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>>>>
 * CHECK:               ocaml.yield %[[VAL_4]] : !ocaml.ref<!ocaml.list<!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>>>>
 * CHECK:             }
 * CHECK:             %[[VAL_5:.*]] = arith.constant 1 : i64
 * CHECK:             %[[VAL_6:.*]] = ocaml.convert %[[VAL_5]] from i64 to !ocaml.box<i64>
 * CHECK:             %[[VAL_7:.*]] = arith.constant 3 : i64
 * CHECK:             %[[VAL_8:.*]] = ocaml.convert %[[VAL_7]] from i64 to !ocaml.box<i64>
 * CHECK:             %[[VAL_9:.*]] = ocaml.convert %[[VAL_6]] from !ocaml.box<i64> to i64
 * CHECK:             %[[VAL_10:.*]] = ocaml.convert %[[VAL_8]] from !ocaml.box<i64> to i64
 * CHECK:             %[[VAL_11:.*]] = arith.constant 1 : i64
 * CHECK:             scf.for %[[VAL_12:.*]] = %[[VAL_9]] to %[[VAL_10]] step %[[VAL_11]]  : i64 {
 * CHECK:               %[[VAL_13:.*]] = ocaml.convert %[[VAL_12]] from i64 to !ocaml.box<i64>
 * CHECK:               %[[VAL_14:.*]] = ocaml.block : !ocaml.unit {
 * CHECK:                 %[[VAL_15:.*]] = ocaml.block : !ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>> {
 * CHECK:                   %[[VAL_16:.*]] = ocaml.closure.env.new {ocaml.env_for_function = "funexpr$1env$2"} : !ocaml.env
 * CHECK:                   ocaml.closure.env.capture %[[VAL_16]]["i"] = %[[VAL_13]] : !ocaml.box<i64>
 * CHECK:                   %[[VAL_17:.*]] = ocaml.closure.new @funexpr$1 capturing %[[VAL_16]] : !ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>>
 * CHECK:                   ocaml.yield %[[VAL_17]] : !ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>>
 * CHECK:                 }
 * CHECK:                 %[[VAL_18:.*]] = ocaml.load %[[VAL_2]] : !ocaml.ref<!ocaml.list<!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>>>>
 * CHECK:                 %[[VAL_19:.*]] = ocaml.list.cons %[[VAL_15]] :: %[[VAL_18]] : !ocaml.list<!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>>>
 * CHECK:                 ocaml.store %[[VAL_19]] to %[[VAL_2]] : !ocaml.ref<!ocaml.list<!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>>>>
 * CHECK:                 %[[VAL_20:.*]] = ocaml.unit
 * CHECK:                 ocaml.yield %[[VAL_20]] : !ocaml.unit
 * CHECK:               }
 * CHECK:               %[[VAL_21:.*]] = ocaml.unit
 * CHECK:             }
 * CHECK:             %[[VAL_22:.*]] = ocaml.load %[[VAL_2]] : !ocaml.ref<!ocaml.list<!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>>>>
 * CHECK:             ocaml.yield %[[VAL_22]] : !ocaml.list<!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>>>
 * CHECK:           }
 * CHECK:           return %[[VAL_1]] : !ocaml.list<!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>>>
 * CHECK:         }

 * CHECK-LABEL:   ocaml.program : {
 * CHECK:           %[[VAL_0:.*]] = ocaml.closure.env.new {ocaml.env_for_function = "make_addersenv$0"} : !ocaml.env
 * CHECK:           %[[VAL_1:.*]] = ocaml.closure.new @make_adders capturing %[[VAL_0]] : !ocaml.closure<(!ocaml.unit) -> !ocaml.list<!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>>>>
 * CHECK:         }

 *)
