(*
 * NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

 * The script is designed to make adding checks to
 * a test case fast, it is *not* designed to be authoritative
 * about what constitutes a good test! The CHECK should be
 * minimized and named to reflect the test intent.


 * CHECK-LABEL:   func.func private @B(!ocaml.box<i64>) -> !ocaml.variant<"l" is "A" | "B" of !ocaml.box<i64> | "C" of tuple<!ocaml.box<i64>, !ocaml.box<i64>>> attributes {ocaml.unresolved}

 * CHECK-LABEL:   func.func private @A() -> !ocaml.variant<"l" is "A" | "B" of !ocaml.box<i64> | "C" of tuple<!ocaml.box<i64>, !ocaml.box<i64>>> attributes {ocaml.variant_ctor} {
 * CHECK:           %[[VAL_0:.*]] = arith.constant 0 : i64
 * CHECK:           %[[VAL_1:.*]] = ocaml.builtin "variant_ctor_empty"(%[[VAL_0]]) : i64 -> !ocaml.variant<"l" is "A" | "B" of !ocaml.box<i64> | "C" of tuple<!ocaml.box<i64>, !ocaml.box<i64>>>
 * CHECK:           return %[[VAL_1]] : !ocaml.variant<"l" is "A" | "B" of !ocaml.box<i64> | "C" of tuple<!ocaml.box<i64>, !ocaml.box<i64>>>
 * CHECK:         }

 * CHECK-LABEL:   ocaml.program : {
 * CHECK:           %[[VAL_0:.*]] = func.call @A() : () -> !ocaml.variant<"l" is "A" | "B" of !ocaml.box<i64> | "C" of tuple<!ocaml.box<i64>, !ocaml.box<i64>>>
 * CHECK:           %[[VAL_1:.*]] = arith.constant 5 : i64
 * CHECK:           %[[VAL_2:.*]] = ocaml.convert %[[VAL_1]] from i64 to !ocaml.box<i64>
 * CHECK:           %[[VAL_3:.*]] = ocaml.closure.new @B : !ocaml.closure<(!ocaml.box<i64>) -> !ocaml.variant<"l" is "A" | "B" of !ocaml.box<i64> | "C" of tuple<!ocaml.box<i64>, !ocaml.box<i64>>>>
 * CHECK:           %[[VAL_4:.*]] = ocaml.call %[[VAL_3]](%[[VAL_2]]) : (!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.variant<"l" is "A" | "B" of !ocaml.box<i64> | "C" of tuple<!ocaml.box<i64>, !ocaml.box<i64>>>>) : !ocaml.box<i64> -> !ocaml.variant<"l" is "A" | "B" of !ocaml.box<i64> | "C" of tuple<!ocaml.box<i64>, !ocaml.box<i64>>>
 * CHECK:           %[[VAL_5:.*]] = ocaml.block : !ocaml.box<i64> {
 * CHECK:             %[[VAL_6:.*]] = ocaml.block : !ocaml.variant<"l" is "A" | "B" of !ocaml.box<i64> | "C" of tuple<!ocaml.box<i64>, !ocaml.box<i64>>> {
 * CHECK:               %[[VAL_7:.*]] = arith.constant 2 : i64
 * CHECK:               %[[VAL_8:.*]] = ocaml.convert %[[VAL_7]] from i64 to !ocaml.box<i64>
 * CHECK:               %[[VAL_9:.*]] = ocaml.closure.new @B : !ocaml.closure<(!ocaml.box<i64>) -> !ocaml.variant<"l" is "A" | "B" of !ocaml.box<i64> | "C" of tuple<!ocaml.box<i64>, !ocaml.box<i64>>>>
 * CHECK:               %[[VAL_10:.*]] = ocaml.call %[[VAL_9]](%[[VAL_8]]) : (!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.variant<"l" is "A" | "B" of !ocaml.box<i64> | "C" of tuple<!ocaml.box<i64>, !ocaml.box<i64>>>>) : !ocaml.box<i64> -> !ocaml.variant<"l" is "A" | "B" of !ocaml.box<i64> | "C" of tuple<!ocaml.box<i64>, !ocaml.box<i64>>>
 * CHECK:               ocaml.yield %[[VAL_10]] : !ocaml.variant<"l" is "A" | "B" of !ocaml.box<i64> | "C" of tuple<!ocaml.box<i64>, !ocaml.box<i64>>>
 * CHECK:             }
 * CHECK:             %[[VAL_11:.*]] = ocaml.block : !ocaml.box<i64> {
 * CHECK:               %[[VAL_12:.*]] = ocaml.block : !ocaml.box<i64> {
 * CHECK:                 %[[VAL_13:.*]] = ocaml.block : !ocaml.box<i64> {
 * CHECK:                   %[[VAL_14:.*]] = ocaml.pattern_variable : !ocaml.obox
 * CHECK:                   %[[VAL_15:.*]] = ocaml.convert %[[VAL_14]] from !ocaml.obox to !ocaml.variant<"l" is "A" | "B" of !ocaml.box<i64> | "C" of tuple<!ocaml.box<i64>, !ocaml.box<i64>>>
 * CHECK:                   %[[VAL_16:.*]] = ocaml.match %[[VAL_6]] against %[[VAL_15]] : !ocaml.variant<"l" is "A" | "B" of !ocaml.box<i64> | "C" of tuple<!ocaml.box<i64>, !ocaml.box<i64>>>
 * CHECK:                   cf.cond_br %[[VAL_16]], ^bb1, ^bb2
 * CHECK:                 ^bb1:
 * CHECK:                   %[[VAL_17:.*]] = arith.constant 1 : i64
 * CHECK:                   %[[VAL_18:.*]] = ocaml.convert %[[VAL_17]] from i64 to !ocaml.box<i64>
 * CHECK:                   cf.br ^bb5(%[[VAL_18]] : !ocaml.box<i64>)
 * CHECK:                 ^bb2:
 * CHECK:                   %[[VAL_19:.*]] = func.call @A() : () -> !ocaml.variant<"l" is "A" | "B" of !ocaml.box<i64> | "C" of tuple<!ocaml.box<i64>, !ocaml.box<i64>>>
 * CHECK:                   %[[VAL_20:.*]] = ocaml.match %[[VAL_6]] against %[[VAL_19]] : !ocaml.variant<"l" is "A" | "B" of !ocaml.box<i64> | "C" of tuple<!ocaml.box<i64>, !ocaml.box<i64>>>
 * CHECK:                   cf.cond_br %[[VAL_20]], ^bb3, ^bb4
 * CHECK:                 ^bb3:
 * CHECK:                   %[[VAL_21:.*]] = arith.constant 0 : i64
 * CHECK:                   %[[VAL_22:.*]] = ocaml.convert %[[VAL_21]] from i64 to !ocaml.box<i64>
 * CHECK:                   cf.br ^bb5(%[[VAL_22]] : !ocaml.box<i64>)
 * CHECK:                 ^bb4:
 * CHECK:                   %[[VAL_23:.*]] = arith.constant false
 * CHECK:                   cf.assert %[[VAL_23]], "No match found"
 * CHECK:                   %[[VAL_24:.*]] = ocaml.convert %[[VAL_23]] from i1 to !ocaml.box<i64>
 * CHECK:                   cf.br ^bb5(%[[VAL_24]] : !ocaml.box<i64>)
 * CHECK:                 ^bb5(%[[VAL_25:.*]]: !ocaml.box<i64>):
 * CHECK:                   ocaml.yield %[[VAL_25]] : !ocaml.box<i64>
 * CHECK:                 }
 * CHECK:                 ocaml.yield %[[VAL_13]] : !ocaml.box<i64>
 * CHECK:               }
 * CHECK:               ocaml.yield %[[VAL_12]] : !ocaml.box<i64>
 * CHECK:             }
 * CHECK:             ocaml.yield %[[VAL_11]] : !ocaml.box<i64>
 * CHECK:           }
 * CHECK:         }

 *)
