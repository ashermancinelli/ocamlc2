(*
 * NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

 * The script is designed to make adding checks to
 * a test case fast, it is *not* designed to be authoritative
 * about what constitutes a good test! The CHECK should be
 * minimized and named to reflect the test intent.


 * CHECK-LABEL:   func.func private @print_newline(!ocaml.unit) -> !ocaml.unit attributes {ocaml.unresolved}
 * CHECK:         func.func private @print_int(!ocaml.box<i64>) -> !ocaml.unit attributes {ocaml.unresolved}
 * CHECK:         func.func private @print_string(!ocaml.sbox) -> !ocaml.unit attributes {ocaml.unresolved}
 * CHECK:         func.func private @"+"(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i64> attributes {ocaml.unresolved}
 * CHECK:         func.func private @Some(!ocaml.box<i64>) -> !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>> attributes {ocaml.unresolved}
 * CHECK:         func.func private @"="(!ocaml.obox, !ocaml.obox) -> !ocaml.box<i1> attributes {ocaml.unresolved}

 * CHECK-LABEL:   func.func private @None() -> !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>> attributes {ocaml.variant_ctor} {
 * CHECK:           %[[VAL_0:.*]] = arith.constant 0 : i64
 * CHECK:           %[[VAL_1:.*]] = ocaml.builtin "variant_ctor_empty"(%[[VAL_0]]) : i64 -> !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>
 * CHECK:           return %[[VAL_1]] : !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>
 * CHECK:         }
 * CHECK:         func.func private @Array.length(!ocaml.array<!ocaml.obox>) -> !ocaml.box<i64> attributes {ocaml.unresolved}
 * CHECK:         func.func private @">="(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i1> attributes {ocaml.unresolved}

 * CHECK-LABEL:   func.func private @aux(
 * CHECK-SAME:                           %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !ocaml.box<i64>) -> !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>> attributes {ocaml.env = "auxenv$1", ocaml.recursive} {
 * CHECK:           %[[VAL_1:.*]] = ocaml.closure.env.get_current : !ocaml.env
 * CHECK:           %[[VAL_2:.*]] = ocaml.closure.env.get %[[VAL_1]]["item"] -> !ocaml.obox
 * CHECK:           %[[VAL_3:.*]] = ocaml.closure.env.get_current : !ocaml.env
 * CHECK:           %[[VAL_4:.*]] = ocaml.closure.env.get %[[VAL_3]]["arr"] -> !ocaml.array<!ocaml.obox>
 * CHECK:           %[[VAL_5:.*]] = ocaml.closure.new @Array.length : !ocaml.closure<(!ocaml.array<!ocaml.obox>) -> !ocaml.box<i64>>
 * CHECK:           %[[VAL_6:.*]] = ocaml.call %[[VAL_5]](%[[VAL_4]]) : (!ocaml.closure<(!ocaml.array<!ocaml.obox>) -> !ocaml.box<i64>>) : !ocaml.array<!ocaml.obox> -> !ocaml.box<i64>
 * CHECK:           %[[VAL_7:.*]] = ocaml.closure.new @">=" : !ocaml.closure<(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i1>>
 * CHECK:           %[[VAL_8:.*]] = ocaml.call %[[VAL_7]](%[[VAL_0]], %[[VAL_6]]) : (!ocaml.closure<(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i1>>) : !ocaml.box<i64>, !ocaml.box<i64> -> !ocaml.box<i1>
 * CHECK:           %[[VAL_9:.*]] = ocaml.convert %[[VAL_8]] from !ocaml.box<i1> to i1
 * CHECK:           %[[VAL_10:.*]] = scf.if %[[VAL_9]] -> (!ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>) {
 * CHECK:             %[[VAL_11:.*]] = func.call @None() : () -> !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>
 * CHECK:             scf.yield %[[VAL_11]] : !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>
 * CHECK:           } else {
 * CHECK:             %[[VAL_12:.*]] = ocaml.convert %[[VAL_0]] from !ocaml.box<i64> to i64
 * CHECK:             %[[VAL_13:.*]] = ocaml.array.get %[[VAL_4]]{{\[}}%[[VAL_12]]] : <!ocaml.obox>, i64 -> !ocaml.obox
 * CHECK:             %[[VAL_14:.*]] = ocaml.closure.new @"=" : !ocaml.closure<(!ocaml.obox, !ocaml.obox) -> !ocaml.box<i1>>
 * CHECK:             %[[VAL_15:.*]] = ocaml.call %[[VAL_14]](%[[VAL_13]], %[[VAL_2]]) : (!ocaml.closure<(!ocaml.obox, !ocaml.obox) -> !ocaml.box<i1>>) : !ocaml.obox, !ocaml.obox -> !ocaml.box<i1>
 * CHECK:             %[[VAL_16:.*]] = ocaml.convert %[[VAL_15]] from !ocaml.box<i1> to i1
 * CHECK:             %[[VAL_17:.*]] = scf.if %[[VAL_16]] -> (!ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>) {
 * CHECK:               %[[VAL_18:.*]] = ocaml.closure.new @Some : !ocaml.closure<(!ocaml.box<i64>) -> !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>>
 * CHECK:               %[[VAL_19:.*]] = ocaml.call %[[VAL_18]](%[[VAL_0]]) : (!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>>) : !ocaml.box<i64> -> !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>
 * CHECK:               scf.yield %[[VAL_19]] : !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>
 * CHECK:             } else {
 * CHECK:               %[[VAL_20:.*]] = arith.constant 1 : i64
 * CHECK:               %[[VAL_21:.*]] = ocaml.convert %[[VAL_20]] from i64 to !ocaml.box<i64>
 * CHECK:               %[[VAL_22:.*]] = ocaml.closure.new @"+" : !ocaml.closure<(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i64>>
 * CHECK:               %[[VAL_23:.*]] = ocaml.call %[[VAL_22]](%[[VAL_0]], %[[VAL_21]]) : (!ocaml.closure<(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i64>>) : !ocaml.box<i64>, !ocaml.box<i64> -> !ocaml.box<i64>
 * CHECK:               %[[VAL_24:.*]] = ocaml.closure.env.get_current : !ocaml.env
 * CHECK:               %[[VAL_25:.*]] = ocaml.closure.new @aux capturing %[[VAL_24]] : !ocaml.closure<(!ocaml.box<i64>) -> !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>>
 * CHECK:               %[[VAL_26:.*]] = ocaml.call %[[VAL_25]](%[[VAL_23]]) : (!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>>) : !ocaml.box<i64> -> !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>
 * CHECK:               scf.yield %[[VAL_26]] : !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>
 * CHECK:             }
 * CHECK:             scf.yield %[[VAL_17]] : !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>
 * CHECK:           }
 * CHECK:           return %[[VAL_10]] : !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>
 * CHECK:         }

 * CHECK-LABEL:   func.func private @find_index(
 * CHECK-SAME:                                  %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !ocaml.obox,
 * CHECK-SAME:                                  %[[VAL_1:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !ocaml.array<!ocaml.obox>) -> !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>> attributes {ocaml.env = "find_indexenv$0"} {
 * CHECK:           %[[VAL_2:.*]] = ocaml.block : !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>> {
 * CHECK:             %[[VAL_3:.*]] = ocaml.closure.env.new {ocaml.env_for_function = "auxenv$1"} : !ocaml.env
 * CHECK:             ocaml.closure.env.capture %[[VAL_3]]["item"] = %[[VAL_0]] : !ocaml.obox
 * CHECK:             ocaml.closure.env.capture %[[VAL_3]]["arr"] = %[[VAL_1]] : !ocaml.array<!ocaml.obox>
 * CHECK:             %[[VAL_4:.*]] = ocaml.closure.new @aux capturing %[[VAL_3]] : !ocaml.closure<(!ocaml.box<i64>) -> !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>>
 * CHECK:             %[[VAL_5:.*]] = arith.constant 0 : i64
 * CHECK:             %[[VAL_6:.*]] = ocaml.convert %[[VAL_5]] from i64 to !ocaml.box<i64>
 * CHECK:             %[[VAL_7:.*]] = ocaml.call %[[VAL_4]](%[[VAL_6]]) : (!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>>) : !ocaml.box<i64> -> !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>
 * CHECK:             ocaml.yield %[[VAL_7]] : !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>
 * CHECK:           }
 * CHECK:           return %[[VAL_2]] : !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>
 * CHECK:         }

 * CHECK-LABEL:   ocaml.program : {
 * CHECK:           %[[VAL_0:.*]] = ocaml.closure.env.new {ocaml.env_for_function = "find_indexenv$0"} : !ocaml.env
 * CHECK:           %[[VAL_1:.*]] = ocaml.closure.new @find_index capturing %[[VAL_0]] : !ocaml.closure<(!ocaml.obox, !ocaml.array<!ocaml.obox>) -> !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>>
 * CHECK:           %[[VAL_2:.*]] = ocaml.block : !ocaml.unit {
 * CHECK:             %[[VAL_3:.*]] = arith.constant 1 : i64
 * CHECK:             %[[VAL_4:.*]] = ocaml.convert %[[VAL_3]] from i64 to !ocaml.box<i64>
 * CHECK:             %[[VAL_5:.*]] = arith.constant 2 : i64
 * CHECK:             %[[VAL_6:.*]] = ocaml.convert %[[VAL_5]] from i64 to !ocaml.box<i64>
 * CHECK:             %[[VAL_7:.*]] = arith.constant 3 : i64
 * CHECK:             %[[VAL_8:.*]] = ocaml.convert %[[VAL_7]] from i64 to !ocaml.box<i64>
 * CHECK:             %[[VAL_9:.*]] = arith.constant 4 : i64
 * CHECK:             %[[VAL_10:.*]] = ocaml.convert %[[VAL_9]] from i64 to !ocaml.box<i64>
 * CHECK:             %[[VAL_11:.*]] = arith.constant 5 : i64
 * CHECK:             %[[VAL_12:.*]] = ocaml.convert %[[VAL_11]] from i64 to !ocaml.box<i64>
 * CHECK:             %[[VAL_13:.*]] = ocaml.array.from_elements{{\[}}%[[VAL_4]], %[[VAL_6]], %[[VAL_8]], %[[VAL_10]], %[[VAL_12]]] : !ocaml.box<i64>, !ocaml.box<i64>, !ocaml.box<i64>, !ocaml.box<i64>, !ocaml.box<i64> -> <!ocaml.box<i64>>
 * CHECK:             %[[VAL_14:.*]] = ocaml.block : !ocaml.unit {
 * CHECK:               %[[VAL_15:.*]] = arith.constant 3 : i64
 * CHECK:               %[[VAL_16:.*]] = ocaml.convert %[[VAL_15]] from i64 to !ocaml.box<i64>
 * CHECK:               %[[VAL_17:.*]] = ocaml.convert %[[VAL_16]] from !ocaml.box<i64> to !ocaml.obox
 * CHECK:               %[[VAL_18:.*]] = ocaml.convert %[[VAL_13]] from !ocaml.array<!ocaml.box<i64>> to !ocaml.array<!ocaml.obox>
 * CHECK:               %[[VAL_19:.*]] = ocaml.call %[[VAL_1]](%[[VAL_16]], %[[VAL_13]]) : (!ocaml.closure<(!ocaml.obox, !ocaml.array<!ocaml.obox>) -> !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>>) : !ocaml.box<i64>, !ocaml.array<!ocaml.box<i64>> -> !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>
 * CHECK:               %[[VAL_20:.*]] = ocaml.block : !ocaml.unit {
 * CHECK:                 %[[VAL_21:.*]] = func.call @None() : () -> !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>
 * CHECK:                 %[[VAL_22:.*]] = ocaml.match %[[VAL_19]] against %[[VAL_21]] : !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>
 * CHECK:                 cf.cond_br %[[VAL_22]], ^bb1, ^bb2
 * CHECK:               ^bb1:
 * CHECK:                 %[[VAL_23:.*]] = ocaml.embox_string "3 not found in array"
 * CHECK:                 %[[VAL_24:.*]] = ocaml.closure.new @print_string : !ocaml.closure<(!ocaml.sbox) -> !ocaml.unit>
 * CHECK:                 %[[VAL_25:.*]] = ocaml.call %[[VAL_24]](%[[VAL_23]]) : (!ocaml.closure<(!ocaml.sbox) -> !ocaml.unit>) : !ocaml.sbox -> !ocaml.unit
 * CHECK:                 %[[VAL_26:.*]] = ocaml.unit
 * CHECK:                 %[[VAL_27:.*]] = ocaml.closure.new @print_newline : !ocaml.closure<(!ocaml.unit) -> !ocaml.unit>
 * CHECK:                 %[[VAL_28:.*]] = ocaml.call %[[VAL_27]](%[[VAL_26]]) : (!ocaml.closure<(!ocaml.unit) -> !ocaml.unit>) : !ocaml.unit -> !ocaml.unit
 * CHECK:                 cf.br ^bb5(%[[VAL_28]] : !ocaml.unit)
 * CHECK:               ^bb2:
 * CHECK:                 %[[VAL_29:.*]] = ocaml.pattern_variable : !ocaml.box<i64>
 * CHECK:                 %[[VAL_30:.*]] = func.call @Some(%[[VAL_29]]) : (!ocaml.box<i64>) -> !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>
 * CHECK:                 %[[VAL_31:.*]] = ocaml.match %[[VAL_19]] against %[[VAL_30]] : !ocaml.variant<"option" is "None" or "Some" of !ocaml.box<i64>>
 * CHECK:                 cf.cond_br %[[VAL_31]], ^bb3, ^bb4
 * CHECK:               ^bb3:
 * CHECK:                 %[[VAL_32:.*]] = ocaml.embox_string "Index of 3: "
 * CHECK:                 %[[VAL_33:.*]] = ocaml.closure.new @print_string : !ocaml.closure<(!ocaml.sbox) -> !ocaml.unit>
 * CHECK:                 %[[VAL_34:.*]] = ocaml.call %[[VAL_33]](%[[VAL_32]]) : (!ocaml.closure<(!ocaml.sbox) -> !ocaml.unit>) : !ocaml.sbox -> !ocaml.unit
 * CHECK:                 %[[VAL_35:.*]] = ocaml.closure.new @print_int : !ocaml.closure<(!ocaml.box<i64>) -> !ocaml.unit>
 * CHECK:                 %[[VAL_36:.*]] = ocaml.call %[[VAL_35]](%[[VAL_29]]) : (!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.unit>) : !ocaml.box<i64> -> !ocaml.unit
 * CHECK:                 %[[VAL_37:.*]] = ocaml.unit
 * CHECK:                 %[[VAL_38:.*]] = ocaml.closure.new @print_newline : !ocaml.closure<(!ocaml.unit) -> !ocaml.unit>
 * CHECK:                 %[[VAL_39:.*]] = ocaml.call %[[VAL_38]](%[[VAL_37]]) : (!ocaml.closure<(!ocaml.unit) -> !ocaml.unit>) : !ocaml.unit -> !ocaml.unit
 * CHECK:                 cf.br ^bb5(%[[VAL_39]] : !ocaml.unit)
 * CHECK:               ^bb4:
 * CHECK:                 %[[VAL_40:.*]] = arith.constant false
 * CHECK:                 cf.assert %[[VAL_40]], "No match found"
 * CHECK:                 %[[VAL_41:.*]] = ocaml.convert %[[VAL_40]] from i1 to !ocaml.unit
 * CHECK:                 cf.br ^bb5(%[[VAL_41]] : !ocaml.unit)
 * CHECK:               ^bb5(%[[VAL_42:.*]]: !ocaml.unit):
 * CHECK:                 ocaml.yield %[[VAL_42]] : !ocaml.unit
 * CHECK:               }
 * CHECK:               %[[VAL_43:.*]] = ocaml.unit
 * CHECK:               ocaml.yield %[[VAL_43]] : !ocaml.unit
 * CHECK:             }
 * CHECK:             %[[VAL_44:.*]] = ocaml.unit
 * CHECK:             ocaml.yield %[[VAL_44]] : !ocaml.unit
 * CHECK:           }
 * CHECK:         }

 *)
