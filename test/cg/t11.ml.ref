(*
 * NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

 * The script is designed to make adding checks to
 * a test case fast, it is *not* designed to be authoritative
 * about what constitutes a good test! The CHECK should be
 * minimized and named to reflect the test intent.


 * CHECK-LABEL:   func.func private @print_newline(!ocaml.unit) -> !ocaml.unit
 * CHECK:         func.func private @print_int(!ocaml.box<i64>) -> !ocaml.unit
 * CHECK:         func.func private @print_string(!ocaml.sbox) -> !ocaml.unit
 * CHECK:         func.func private @"+"(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i64>
 * CHECK:         func.func private @Some(!ocaml.box<i64>) -> !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>
 * CHECK:         func.func private @"="(!ocaml.obox, !ocaml.obox) -> !ocaml.box<i1>

 * CHECK-LABEL:   func.func private @None() -> !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>> attributes {ocaml.variant_ctor} {
 * CHECK:           %[[VAL_0:.*]] = arith.constant 0 : i64
 * CHECK:           %[[VAL_1:.*]] = ocaml.builtin "variant_ctor_empty"(%[[VAL_0]]) : i64 -> !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>
 * CHECK:           return %[[VAL_1]] : !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>
 * CHECK:         }
 * CHECK:         func.func private @Array.length(!ocaml.array<!ocaml.obox>) -> !ocaml.box<i64>
 * CHECK:         func.func private @">="(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i1>

 * CHECK-LABEL:   func.func private @aux(
 * CHECK-SAME:                           %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !ocaml.box<i64>) -> !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>> attributes {env = "auxenv$1"} {
 * CHECK:           %[[VAL_1:.*]] = ocaml.closure.env.get_current : !ocaml.env
 * CHECK:           %[[VAL_2:.*]] = ocaml.closure.env.get %[[VAL_1]]["item"] -> !ocaml.obox
 * CHECK:           %[[VAL_3:.*]] = ocaml.closure.env.get_current : !ocaml.env
 * CHECK:           %[[VAL_4:.*]] = ocaml.closure.env.get %[[VAL_3]]["arr"] -> !ocaml.array<!ocaml.obox>
 * CHECK:           %[[VAL_5:.*]] = call @Array.length(%[[VAL_4]]) : (!ocaml.array<!ocaml.obox>) -> !ocaml.box<i64>
 * CHECK:           %[[VAL_6:.*]] = call @">="(%[[VAL_0]], %[[VAL_5]]) : (!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i1>
 * CHECK:           %[[VAL_7:.*]] = ocaml.convert %[[VAL_6]] from !ocaml.box<i1> to i1
 * CHECK:           %[[VAL_8:.*]] = scf.if %[[VAL_7]] -> (!ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>) {
 * CHECK:             %[[VAL_9:.*]] = func.call @None() : () -> !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>
 * CHECK:             scf.yield %[[VAL_9]] : !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>
 * CHECK:           } else {
 * CHECK:             %[[VAL_10:.*]] = ocaml.convert %[[VAL_0]] from !ocaml.box<i64> to i64
 * CHECK:             %[[VAL_11:.*]] = ocaml.array.get %[[VAL_4]]{{\[}}%[[VAL_10]]] : <!ocaml.obox>, i64 -> !ocaml.obox
 * CHECK:             %[[VAL_12:.*]] = func.call @"="(%[[VAL_11]], %[[VAL_2]]) : (!ocaml.obox, !ocaml.obox) -> !ocaml.box<i1>
 * CHECK:             %[[VAL_13:.*]] = ocaml.convert %[[VAL_12]] from !ocaml.box<i1> to i1
 * CHECK:             %[[VAL_14:.*]] = scf.if %[[VAL_13]] -> (!ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>) {
 * CHECK:               %[[VAL_15:.*]] = func.call @Some(%[[VAL_0]]) : (!ocaml.box<i64>) -> !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>
 * CHECK:               scf.yield %[[VAL_15]] : !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>
 * CHECK:             } else {
 * CHECK:               %[[VAL_16:.*]] = arith.constant 1 : i64
 * CHECK:               %[[VAL_17:.*]] = ocaml.convert %[[VAL_16]] from i64 to !ocaml.box<i64>
 * CHECK:               %[[VAL_18:.*]] = func.call @"+"(%[[VAL_0]], %[[VAL_17]]) : (!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i64>
 * CHECK:               %[[VAL_19:.*]] = func.call @aux(%[[VAL_18]]) : (!ocaml.box<i64>) -> !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>
 * CHECK:               scf.yield %[[VAL_19]] : !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>
 * CHECK:             }
 * CHECK:             scf.yield %[[VAL_14]] : !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>
 * CHECK:           }
 * CHECK:           return %[[VAL_8]] : !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>
 * CHECK:         }

 * CHECK-LABEL:   func.func private @find_index(
 * CHECK-SAME:                                  %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !ocaml.obox,
 * CHECK-SAME:                                  %[[VAL_1:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !ocaml.array<!ocaml.obox>) -> !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>> attributes {env = "find_indexenv$0"} {
 * CHECK:           %[[VAL_2:.*]] = ocaml.block : !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>> {
 * CHECK:             %[[VAL_3:.*]] = ocaml.closure.env.new {for = "auxenv$1"}
 * CHECK:             ocaml.closure.env.capture %[[VAL_3]]["item"] = %[[VAL_0]] : !ocaml.obox
 * CHECK:             ocaml.closure.env.capture %[[VAL_3]]["arr"] = %[[VAL_1]] : !ocaml.array<!ocaml.obox>
 * CHECK:             %[[VAL_4:.*]] = ocaml.closure.new @aux capturing %[[VAL_3]] : <(!ocaml.box<i64>) -> !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>>
 * CHECK:             %[[VAL_5:.*]] = arith.constant 0 : i64
 * CHECK:             %[[VAL_6:.*]] = ocaml.convert %[[VAL_5]] from i64 to !ocaml.box<i64>
 * CHECK:             %[[VAL_7:.*]] = ocaml.convert %[[VAL_6]] from !ocaml.box<i64> to !ocaml.box<i64>
 * CHECK:             %[[VAL_8:.*]] = ocaml.call %[[VAL_4]](%[[VAL_6]]) : (<(!ocaml.box<i64>) -> !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>>) -> !ocaml.box<i64> -> !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>
 * CHECK:             ocaml.yield %[[VAL_8]] : !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>
 * CHECK:           }
 * CHECK:           return %[[VAL_2]] : !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>
 * CHECK:         }

 * CHECK-LABEL:   ocaml.program : {
 * CHECK:           %[[VAL_0:.*]] = ocaml.closure.env.new {for = "find_indexenv$0"}
 * CHECK:           %[[VAL_1:.*]] = ocaml.closure.new @find_index capturing %[[VAL_0]] : <(!ocaml.obox, !ocaml.array<!ocaml.obox>) -> !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>>
 * CHECK:           %[[VAL_2:.*]] = ocaml.block : !ocaml.unit {
 * CHECK:             %[[VAL_3:.*]] = arith.constant 1 : i64
 * CHECK:             %[[VAL_4:.*]] = ocaml.convert %[[VAL_3]] from i64 to !ocaml.box<i64>
 * CHECK:             %[[VAL_5:.*]] = arith.constant 2 : i64
 * CHECK:             %[[VAL_6:.*]] = ocaml.convert %[[VAL_5]] from i64 to !ocaml.box<i64>
 * CHECK:             %[[VAL_7:.*]] = arith.constant 3 : i64
 * CHECK:             %[[VAL_8:.*]] = ocaml.convert %[[VAL_7]] from i64 to !ocaml.box<i64>
 * CHECK:             %[[VAL_9:.*]] = arith.constant 4 : i64
 * CHECK:             %[[VAL_10:.*]] = ocaml.convert %[[VAL_9]] from i64 to !ocaml.box<i64>
 * CHECK:             %[[VAL_11:.*]] = arith.constant 5 : i64
 * CHECK:             %[[VAL_12:.*]] = ocaml.convert %[[VAL_11]] from i64 to !ocaml.box<i64>
 * CHECK:             %[[VAL_13:.*]] = ocaml.array.from_elements{{\[}}%[[VAL_4]], %[[VAL_6]], %[[VAL_8]], %[[VAL_10]], %[[VAL_12]]] : !ocaml.box<i64>, !ocaml.box<i64>, !ocaml.box<i64>, !ocaml.box<i64>, !ocaml.box<i64> -> <!ocaml.box<i64>>
 * CHECK:             %[[VAL_14:.*]] = ocaml.block : !ocaml.unit {
 * CHECK:               %[[VAL_15:.*]] = arith.constant 3 : i64
 * CHECK:               %[[VAL_16:.*]] = ocaml.convert %[[VAL_15]] from i64 to !ocaml.box<i64>
 * CHECK:               %[[VAL_17:.*]] = ocaml.convert %[[VAL_16]] from !ocaml.box<i64> to !ocaml.obox
 * CHECK:               %[[VAL_18:.*]] = ocaml.convert %[[VAL_13]] from !ocaml.array<!ocaml.box<i64>> to !ocaml.array<!ocaml.obox>
 * CHECK:               %[[VAL_19:.*]] = ocaml.call %[[VAL_1]](%[[VAL_16]], %[[VAL_13]]) : (<(!ocaml.obox, !ocaml.array<!ocaml.obox>) -> !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>>) -> !ocaml.box<i64>, !ocaml.array<!ocaml.box<i64>> -> !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>
 * CHECK:               %[[VAL_20:.*]] = ocaml.block : !ocaml.unit {
 * CHECK:                 %[[VAL_21:.*]] = func.call @None() : () -> !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>
 * CHECK:                 %[[VAL_22:.*]] = ocaml.match %[[VAL_19]] against %[[VAL_21]] : !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>
 * CHECK:                 cf.cond_br %[[VAL_22]], ^bb1, ^bb2
 * CHECK:               ^bb1:
 * CHECK:                 %[[VAL_23:.*]] = ocaml.embox_string "3 not found in array"
 * CHECK:                 %[[VAL_24:.*]] = func.call @print_string(%[[VAL_23]]) : (!ocaml.sbox) -> !ocaml.unit
 * CHECK:                 %[[VAL_25:.*]] = ocaml.unit
 * CHECK:                 %[[VAL_26:.*]] = func.call @print_newline(%[[VAL_25]]) : (!ocaml.unit) -> !ocaml.unit
 * CHECK:                 cf.br ^bb5(%[[VAL_26]] : !ocaml.unit)
 * CHECK:               ^bb2:
 * CHECK:                 %[[VAL_27:.*]] = ocaml.pattern_variable : !ocaml.box<i64>
 * CHECK:                 %[[VAL_28:.*]] = func.call @Some(%[[VAL_27]]) : (!ocaml.box<i64>) -> !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>
 * CHECK:                 %[[VAL_29:.*]] = ocaml.match %[[VAL_19]] against %[[VAL_28]] : !ocaml.variant<"option" is "None" | "Some" of !ocaml.box<i64>>
 * CHECK:                 cf.cond_br %[[VAL_29]], ^bb3, ^bb4
 * CHECK:               ^bb3:
 * CHECK:                 %[[VAL_30:.*]] = ocaml.embox_string "Index of 3: "
 * CHECK:                 %[[VAL_31:.*]] = func.call @print_string(%[[VAL_30]]) : (!ocaml.sbox) -> !ocaml.unit
 * CHECK:                 %[[VAL_32:.*]] = func.call @print_int(%[[VAL_27]]) : (!ocaml.box<i64>) -> !ocaml.unit
 * CHECK:                 %[[VAL_33:.*]] = ocaml.unit
 * CHECK:                 %[[VAL_34:.*]] = func.call @print_newline(%[[VAL_33]]) : (!ocaml.unit) -> !ocaml.unit
 * CHECK:                 cf.br ^bb5(%[[VAL_34]] : !ocaml.unit)
 * CHECK:               ^bb4:
 * CHECK:                 %[[VAL_35:.*]] = arith.constant false
 * CHECK:                 cf.assert %[[VAL_35]], "No match found"
 * CHECK:                 %[[VAL_36:.*]] = ocaml.convert %[[VAL_35]] from i1 to !ocaml.unit
 * CHECK:                 cf.br ^bb5(%[[VAL_36]] : !ocaml.unit)
 * CHECK:               ^bb5(%[[VAL_37:.*]]: !ocaml.unit):
 * CHECK:                 ocaml.yield %[[VAL_37]] : !ocaml.unit
 * CHECK:               }
 * CHECK:               %[[VAL_38:.*]] = ocaml.unit
 * CHECK:               ocaml.yield %[[VAL_38]] : !ocaml.unit
 * CHECK:             }
 * CHECK:             %[[VAL_39:.*]] = ocaml.unit
 * CHECK:             ocaml.yield %[[VAL_39]] : !ocaml.unit
 * CHECK:           }
 * CHECK:         }

 *)
