(*
 * NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

 * The script is designed to make adding checks to
 * a test case fast, it is *not* designed to be authoritative
 * about what constitutes a good test! The CHECK should be
 * minimized and named to reflect the test intent.


 * CHECK-LABEL:   func.func private @print_int(!ocaml.box<i64>) -> !ocaml.unit attributes {ocaml.external = "ocaml_print_int"}
 * CHECK:         func.func private @"+"(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i64> attributes {ocaml.external = "ocaml_add"}

 * CHECK-LABEL:   ocaml.program : {
 * CHECK:           %[[VAL_0:.*]] = ocaml.closure.new @"+" : !ocaml.closure<(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i64>>
 * CHECK:           %[[VAL_1:.*]] = ocaml.closure.new @print_int : !ocaml.closure<(!ocaml.box<i64>) -> !ocaml.unit>
 * CHECK:           %[[VAL_2:.*]] = ocaml.block : !ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>> {
 * CHECK:             %[[VAL_3:.*]] = arith.constant 1 : i64
 * CHECK:             %[[VAL_4:.*]] = ocaml.convert %[[VAL_3]] from i64 to !ocaml.box<i64>
 * CHECK:             %[[VAL_5:.*]] = ocaml.closure.new @"+" : !ocaml.closure<(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i64>>
 * CHECK:             %[[VAL_6:.*]] = ocaml.closure.curry %[[VAL_5]](%[[VAL_4]]) : !ocaml.closure<(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i64>>, (!ocaml.box<i64>) -> !ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>>
 * CHECK:             ocaml.yield %[[VAL_6]] : !ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>>
 * CHECK:           }
 * CHECK:           %[[VAL_7:.*]] = ocaml.block : !ocaml.unit {
 * CHECK:             %[[VAL_8:.*]] = ocaml.block : !ocaml.box<i64> {
 * CHECK:               %[[VAL_9:.*]] = arith.constant 1 : i64
 * CHECK:               %[[VAL_10:.*]] = ocaml.convert %[[VAL_9]] from i64 to !ocaml.box<i64>
 * CHECK:               %[[VAL_11:.*]] = ocaml.call %[[VAL_2]](%[[VAL_10]]) : (!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.box<i64>>) : !ocaml.box<i64> -> !ocaml.box<i64>
 * CHECK:               ocaml.yield %[[VAL_11]] : !ocaml.box<i64>
 * CHECK:             }
 * CHECK:             %[[VAL_12:.*]] = ocaml.closure.new @print_int : !ocaml.closure<(!ocaml.box<i64>) -> !ocaml.unit>
 * CHECK:             %[[VAL_13:.*]] = ocaml.call %[[VAL_12]](%[[VAL_8]]) : (!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.unit>) : !ocaml.box<i64> -> !ocaml.unit
 * CHECK:             %[[VAL_14:.*]] = ocaml.unit
 * CHECK:             ocaml.yield %[[VAL_14]] : !ocaml.unit
 * CHECK:           }
 * CHECK:         }

 *)
