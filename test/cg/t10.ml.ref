(*
 * NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

 * The script is designed to make adding checks to
 * a test case fast, it is *not* designed to be authoritative
 * about what constitutes a good test! The CHECK should be
 * minimized and named to reflect the test intent.


 * CHECK-LABEL:   func.func private @print_string(!ocaml.sbox) -> !ocaml.unit attributes {unresolved}
 * CHECK:         func.func private @">"(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i1> attributes {unresolved}

 * CHECK-LABEL:   func.func private @test(
 * CHECK-SAME:                            %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !ocaml.box<i64>) -> !ocaml.sbox attributes {env = "testenv$0"} {
 * CHECK:           %[[VAL_1:.*]] = arith.constant 10 : i64
 * CHECK:           %[[VAL_2:.*]] = ocaml.convert %[[VAL_1]] from i64 to !ocaml.box<i64>
 * CHECK:           %[[VAL_3:.*]] = ocaml.closure.new @">" : !ocaml.closure<(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i1>>
 * CHECK:           %[[VAL_4:.*]] = ocaml.call %[[VAL_3]](%[[VAL_0]], %[[VAL_2]]) : (!ocaml.closure<(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i1>>) : !ocaml.box<i64>, !ocaml.box<i64> -> !ocaml.box<i1>
 * CHECK:           %[[VAL_5:.*]] = ocaml.convert %[[VAL_4]] from !ocaml.box<i1> to i1
 * CHECK:           %[[VAL_6:.*]] = scf.if %[[VAL_5]] -> (!ocaml.sbox) {
 * CHECK:             %[[VAL_7:.*]] = ocaml.embox_string "large"
 * CHECK:             scf.yield %[[VAL_7]] : !ocaml.sbox
 * CHECK:           } else {
 * CHECK:             %[[VAL_8:.*]] = arith.constant 5 : i64
 * CHECK:             %[[VAL_9:.*]] = ocaml.convert %[[VAL_8]] from i64 to !ocaml.box<i64>
 * CHECK:             %[[VAL_10:.*]] = ocaml.closure.new @">" : !ocaml.closure<(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i1>>
 * CHECK:             %[[VAL_11:.*]] = ocaml.call %[[VAL_10]](%[[VAL_0]], %[[VAL_9]]) : (!ocaml.closure<(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i1>>) : !ocaml.box<i64>, !ocaml.box<i64> -> !ocaml.box<i1>
 * CHECK:             %[[VAL_12:.*]] = ocaml.convert %[[VAL_11]] from !ocaml.box<i1> to i1
 * CHECK:             %[[VAL_13:.*]] = scf.if %[[VAL_12]] -> (!ocaml.sbox) {
 * CHECK:               %[[VAL_14:.*]] = ocaml.embox_string "medium"
 * CHECK:               scf.yield %[[VAL_14]] : !ocaml.sbox
 * CHECK:             } else {
 * CHECK:               %[[VAL_15:.*]] = arith.constant 0 : i64
 * CHECK:               %[[VAL_16:.*]] = ocaml.convert %[[VAL_15]] from i64 to !ocaml.box<i64>
 * CHECK:               %[[VAL_17:.*]] = ocaml.closure.new @">" : !ocaml.closure<(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i1>>
 * CHECK:               %[[VAL_18:.*]] = ocaml.call %[[VAL_17]](%[[VAL_0]], %[[VAL_16]]) : (!ocaml.closure<(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i1>>) : !ocaml.box<i64>, !ocaml.box<i64> -> !ocaml.box<i1>
 * CHECK:               %[[VAL_19:.*]] = ocaml.convert %[[VAL_18]] from !ocaml.box<i1> to i1
 * CHECK:               %[[VAL_20:.*]] = scf.if %[[VAL_19]] -> (!ocaml.sbox) {
 * CHECK:                 %[[VAL_21:.*]] = ocaml.embox_string "small"
 * CHECK:                 scf.yield %[[VAL_21]] : !ocaml.sbox
 * CHECK:               } else {
 * CHECK:                 %[[VAL_22:.*]] = ocaml.embox_string "negative or zero"
 * CHECK:                 scf.yield %[[VAL_22]] : !ocaml.sbox
 * CHECK:               }
 * CHECK:               scf.yield %[[VAL_20]] : !ocaml.sbox
 * CHECK:             }
 * CHECK:             scf.yield %[[VAL_13]] : !ocaml.sbox
 * CHECK:           }
 * CHECK:           return %[[VAL_6]] : !ocaml.sbox
 * CHECK:         }

 * CHECK-LABEL:   ocaml.program : {
 * CHECK:           %[[VAL_0:.*]] = ocaml.closure.env.new {for = "testenv$0"} : !ocaml.env
 * CHECK:           %[[VAL_1:.*]] = ocaml.closure.new @test capturing %[[VAL_0]] : !ocaml.closure<(!ocaml.box<i64>) -> !ocaml.sbox>
 * CHECK:           %[[VAL_2:.*]] = arith.constant 7 : i64
 * CHECK:           %[[VAL_3:.*]] = ocaml.convert %[[VAL_2]] from i64 to !ocaml.box<i64>
 * CHECK:           %[[VAL_4:.*]] = ocaml.call %[[VAL_1]](%[[VAL_3]]) : (!ocaml.closure<(!ocaml.box<i64>) -> !ocaml.sbox>) : !ocaml.box<i64> -> !ocaml.sbox
 * CHECK:           %[[VAL_5:.*]] = ocaml.closure.new @print_string : !ocaml.closure<(!ocaml.sbox) -> !ocaml.unit>
 * CHECK:           %[[VAL_6:.*]] = ocaml.call %[[VAL_5]](%[[VAL_4]]) : (!ocaml.closure<(!ocaml.sbox) -> !ocaml.unit>) : !ocaml.sbox -> !ocaml.unit
 * CHECK:         }

 *)
