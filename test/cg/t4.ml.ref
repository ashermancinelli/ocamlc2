(*
 * NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

 * The script is designed to make adding checks to
 * a test case fast, it is *not* designed to be authoritative
 * about what constitutes a good test! The CHECK should be
 * minimized and named to reflect the test intent.


 * CHECK-LABEL:   func.func private @print_endline(!ocaml.sbox) -> !ocaml.unit
 * CHECK:         func.func private @print_int(!ocaml.box<i64>) -> !ocaml.unit
 * CHECK:         func.func private @"+"(!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i64>

 * CHECK-LABEL:   func.func private @B(
 * CHECK-SAME:                         %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !ocaml.box<i64>) -> !ocaml.variant<"shape" is "A" | "B" of !ocaml.box<i64>> attributes {ocaml.variant_ctor} {
 * CHECK:           %[[VAL_1:.*]] = arith.constant 1 : i64
 * CHECK:           %[[VAL_2:.*]] = ocaml.builtin "designate_variant"(%[[VAL_1]], %[[VAL_0]]) : i64, !ocaml.box<i64> -> !ocaml.variant<"shape" is "A" | "B" of !ocaml.box<i64>>
 * CHECK:           return %[[VAL_2]] : !ocaml.variant<"shape" is "A" | "B" of !ocaml.box<i64>>
 * CHECK:         }

 * CHECK-LABEL:   func.func private @A() -> !ocaml.variant<"shape" is "A" | "B" of !ocaml.box<i64>> attributes {ocaml.variant_ctor} {
 * CHECK:           %[[VAL_0:.*]] = arith.constant 0 : i64
 * CHECK:           %[[VAL_1:.*]] = ocaml.builtin "variant_ctor_empty"(%[[VAL_0]]) : i64 -> !ocaml.variant<"shape" is "A" | "B" of !ocaml.box<i64>>
 * CHECK:           return %[[VAL_1]] : !ocaml.variant<"shape" is "A" | "B" of !ocaml.box<i64>>
 * CHECK:         }

 * CHECK-LABEL:   func.func private @area(
 * CHECK-SAME:                            %[[VAL_0:[0-9]+|[a-zA-Z$._-][a-zA-Z0-9$._-]*]]: !ocaml.variant<"shape" is "A" | "B" of !ocaml.box<i64>>) -> !ocaml.box<i64> attributes {env = "areaenv$0"} {
 * CHECK:           %[[VAL_1:.*]] = scf.execute_region -> !ocaml.box<i64> {
 * CHECK:             %[[VAL_2:.*]] = ocaml.pattern_variable : !ocaml.box<i64>
 * CHECK:             %[[VAL_3:.*]] = func.call @B(%[[VAL_2]]) : (!ocaml.box<i64>) -> !ocaml.variant<"shape" is "A" | "B" of !ocaml.box<i64>>
 * CHECK:             %[[VAL_4:.*]] = ocaml.match %[[VAL_0]] against %[[VAL_3]] : !ocaml.variant<"shape" is "A" | "B" of !ocaml.box<i64>>
 * CHECK:             cf.cond_br %[[VAL_4]], ^bb1, ^bb2
 * CHECK:           ^bb1:
 * CHECK:             %[[VAL_5:.*]] = arith.constant 1 : i64
 * CHECK:             %[[VAL_6:.*]] = ocaml.convert %[[VAL_5]] from i64 to !ocaml.box<i64>
 * CHECK:             %[[VAL_7:.*]] = func.call @"+"(%[[VAL_2]], %[[VAL_6]]) : (!ocaml.box<i64>, !ocaml.box<i64>) -> !ocaml.box<i64>
 * CHECK:             cf.br ^bb5(%[[VAL_7]] : !ocaml.box<i64>)
 * CHECK:           ^bb2:
 * CHECK:             %[[VAL_8:.*]] = func.call @A() : () -> !ocaml.variant<"shape" is "A" | "B" of !ocaml.box<i64>>
 * CHECK:             %[[VAL_9:.*]] = ocaml.match %[[VAL_0]] against %[[VAL_8]] : !ocaml.variant<"shape" is "A" | "B" of !ocaml.box<i64>>
 * CHECK:             cf.cond_br %[[VAL_9]], ^bb3, ^bb4
 * CHECK:           ^bb3:
 * CHECK:             %[[VAL_10:.*]] = arith.constant 1 : i64
 * CHECK:             %[[VAL_11:.*]] = ocaml.convert %[[VAL_10]] from i64 to !ocaml.box<i64>
 * CHECK:             cf.br ^bb5(%[[VAL_11]] : !ocaml.box<i64>)
 * CHECK:           ^bb4:
 * CHECK:             %[[VAL_12:.*]] = arith.constant false
 * CHECK:             cf.assert %[[VAL_12]], "No match found"
 * CHECK:             %[[VAL_13:.*]] = ocaml.convert %[[VAL_12]] from i1 to !ocaml.box<i64>
 * CHECK:             cf.br ^bb5(%[[VAL_13]] : !ocaml.box<i64>)
 * CHECK:           ^bb5(%[[VAL_14:.*]]: !ocaml.box<i64>):
 * CHECK:             scf.yield %[[VAL_14]] : !ocaml.box<i64>
 * CHECK:           }
 * CHECK:           return %[[VAL_1]] : !ocaml.box<i64>
 * CHECK:         }

 * CHECK-LABEL:   ocaml.program : {
 * CHECK:           %[[VAL_0:.*]] = ocaml.closure.env.new {for = "areaenv$0"}
 * CHECK:           %[[VAL_1:.*]] = ocaml.closure.new @area capturing %[[VAL_0]] : <(!ocaml.variant<"shape" is "A" | "B" of !ocaml.box<i64>>) -> !ocaml.box<i64>>
 * CHECK:           %[[VAL_2:.*]] = func.call @A() : () -> !ocaml.variant<"shape" is "A" | "B" of !ocaml.box<i64>>
 * CHECK:           %[[VAL_3:.*]] = ocaml.call %[[VAL_1]](%[[VAL_2]]) : (<(!ocaml.variant<"shape" is "A" | "B" of !ocaml.box<i64>>) -> !ocaml.box<i64>>) -> !ocaml.variant<"shape" is "A" | "B" of !ocaml.box<i64>> -> !ocaml.box<i64>
 * CHECK:           %[[VAL_4:.*]] = func.call @print_int(%[[VAL_3]]) : (!ocaml.box<i64>) -> !ocaml.unit
 * CHECK:           %[[VAL_5:.*]] = ocaml.embox_string "\22\22"
 * CHECK:           %[[VAL_6:.*]] = func.call @print_endline(%[[VAL_5]]) : (!ocaml.sbox) -> !ocaml.unit
 * CHECK:         }

 *)
